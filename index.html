<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>IVMMA</title>

  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; background:#f4f4f4; margin:0; padding:20px; }
    .container { max-width: 1100px; margin:auto; background:#fff; padding:20px; border-radius:14px; box-shadow:0 6px 20px rgba(0,0,0,.08); }
    h1 { margin: 6px 0 10px; }
    button {
      padding:10px 18px; font-size:16px; cursor:pointer;
      background:#007bff; color:#fff; border:none; border-radius:10px;
      margin: 6px 6px;
    }
    button.secondary { background:#6c757d; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    #status { margin: 8px 0 14px; color:#444; }

    .row { display:flex; justify-content:center; flex-wrap:wrap; gap:8px; align-items:center; }
    .pill { display:inline-block; padding:6px 10px; border-radius:999px; background:#f1f3f5; color:#444; font-size:13px; }
    .hidden { display:none; }

    .grid { display:grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-top: 10px; text-align: left; }
    .card {
      background:#fff; border: 1px solid #eee; border-radius: 14px;
      padding: 14px; box-shadow: 0 4px 16px rgba(0,0,0,.04);
    }
    .kpi-title { font-size: 12px; color:#666; margin-bottom: 6px; }
    .kpi-value { font-size: 28px; font-weight: 800; color:#111; }
    .kpi-sub { font-size: 13px; color:#555; margin-top: 6px; line-height: 1.3; }
    .span-4 { grid-column: span 4; }
    .span-6 { grid-column: span 6; }
    .timer { font-size: 26px; font-weight: 800; letter-spacing: .5px; }

    .controls { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top: 6px; }
    .control {
      display:flex; align-items:center; gap:8px;
      background:#f8f9fa; border:1px solid #eee; border-radius: 12px;
      padding: 10px 12px;
    }
    label { font-size: 13px; color:#444; }
    input[type="number"] { width: 86px; padding: 6px 8px; border-radius: 10px; border:1px solid #ddd; font-size: 14px; }
    input[type="range"] { width: 180px; }
    .small { font-size: 12px; color:#666; }

    .charts { display:grid; grid-template-columns: 1fr; gap: 14px; margin-top: 12px; }
    #chartRight, #chartLeft { width: 100%; height: 360px; }
  </style>
</head>

<body>
  <div class="container">
    <h1>IVMMA</h1>

    <div class="row">
      <button id="connectBtn">Conectar Bluetooth</button>
      <button id="disconnectBtn" class="secondary" disabled>Desconectar</button>
      <button id="startBtn" disabled>Iniciar medición</button>
      <button id="stopBtn" class="secondary" disabled>Detener</button>
      <span class="pill" id="ratePill">0.0 Hz</span>
    </div>

    <p id="status">Estado: Desconectado</p>

    <div id="measWrap" class="hidden">
      <div class="grid">
        <div class="card span-4">
          <div class="kpi-title">Tiempo de medición</div>
          <div class="kpi-value timer" id="timerText">00:00.0</div>
          <div class="kpi-sub">Cronómetro desde “Iniciar medición”.</div>
        </div>

        <div class="card span-4">
          <div class="kpi-title">Activación actual</div>
          <div class="kpi-value" id="actText">D: 0% · I: 0%</div>
          <div class="kpi-sub small">Envolvente normalizada (0–100%).</div>
        </div>

        <div class="card span-4">
          <div class="kpi-title">Simetría</div>
          <div class="kpi-value" id="symText">100%</div>
          <div class="kpi-sub small">100% = igualdad.</div>
        </div>

        <div class="card span-6">
          <div class="kpi-title">Biofeedback (rango objetivo)</div>
          <div class="controls">
            <div class="control">
              <label>Rango %</label>
              <input id="targetLow" type="number" min="0" max="100" value="30">
              <span class="small">a</span>
              <input id="targetHigh" type="number" min="0" max="100" value="50">
              <button id="applyTargetBtn" class="secondary" type="button">Aplicar</button>
            </div>

            <div class="control">
              <label>Umbral reps %</label>
              <input id="thrRange" type="range" min="5" max="80" value="20">
              <span class="pill" id="thrLabel">20%</span>
            </div>

            <div class="control">
              <button id="calRestBtn" class="secondary" type="button">Calibrar reposo (2s)</button>
              <button id="calMaxBtn" class="secondary" type="button">Calibrar máximo (3s)</button>
            </div>
          </div>

          <div class="kpi-sub">
            Tiempo en rango: <b id="inRangeText">D: 0.0s · I: 0.0s · Ambas: 0.0s</b>
            <div class="small">Recomendado: reposo relajado → máximo contracción fuerte.</div>
          </div>
        </div>

        <div class="card span-6">
          <div class="kpi-title">Repeticiones detectadas</div>
          <div class="kpi-value" id="repCountText">D: 0 · I: 0</div>
          <div class="kpi-sub">
            Última rep Derecha: <b id="repRightText">—</b><br>
            Última rep Izquierda: <b id="repLeftText">—</b>
          </div>
        </div>
      </div>

      <div class="charts">
        <div id="chartRight"></div>
        <div id="chartLeft"></div>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // BLE config
    // =========================
    const SERVICE_UUID = "4fafc201-1fb5-459e-8fcc-c5c9c331914b";
    const CHAR_UUID    = "beb5483e-36e1-4688-b7f5-ea07361b26a8";
    const DEVICE_NAME  = "EMG_UPS_WEB";

    // UI refs
    const connectBtn = document.getElementById("connectBtn");
    const disconnectBtn = document.getElementById("disconnectBtn");
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const statusEl = document.getElementById("status");
    const ratePill = document.getElementById("ratePill");

    const measWrap = document.getElementById("measWrap");
    const timerText = document.getElementById("timerText");
    const actText = document.getElementById("actText");
    const symText = document.getElementById("symText");
    const inRangeText = document.getElementById("inRangeText");

    const targetLowEl = document.getElementById("targetLow");
    const targetHighEl = document.getElementById("targetHigh");
    const applyTargetBtn = document.getElementById("applyTargetBtn");

    const thrRange = document.getElementById("thrRange");
    const thrLabel = document.getElementById("thrLabel");

    const calRestBtn = document.getElementById("calRestBtn");
    const calMaxBtn = document.getElementById("calMaxBtn");

    const repCountText = document.getElementById("repCountText");
    const repRightText = document.getElementById("repRightText");
    const repLeftText = document.getElementById("repLeftText");

    // Runtime state
    let deviceRef = null;
    let characteristic = null;

    let isMeasuring = false;
    let t0 = 0;
    let lastSampleT = null;

    // Rate
    let lastRateT = 0;
    let notifCount = 0;

    // Timer RAF
    let timerRAF = null;

    // Charts
    const MAX_POINTS = 900;
    let chartsInited = false;

    // Targets
    let targetLow = 30;
    let targetHigh = 50;

    // Rep threshold
    let thrOn = 20;           // %
    let thrOffFactor = 0.6;   // hysteresis off at 60% of thrOn

    // =========================
    // Robust stats
    // =========================
    function median(arr) {
      if (!arr.length) return 0;
      const a = [...arr].sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function percentile(arr, p) {
      if (!arr.length) return 0;
      const a = [...arr].sort((x,y)=>x-y);
      const idx = (p/100) * (a.length - 1);
      const lo = Math.floor(idx), hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      const w = idx - lo;
      return a[lo]*(1-w) + a[hi]*w;
    }

    // =========================
    // Input anti-spike median filter (mV)
    // =========================
    const MED_WIN = 5;
    let medBufR = [];
    let medBufL = [];
    function pushMedian(buf, v) {
      buf.push(v);
      if (buf.length > MED_WIN) buf.shift();
      return median(buf);
    }

    // =========================
    // Calibration / normalization (mV -> %)
    // =========================
    let baseR = 0, baseL = 0;
    let maxR = 200, maxL = 200;

    let baseLocked = false;
    let maxLocked = false;

    // Auto-max protection: require sustained high samples to update
    let overMaxCountR = 0, overMaxCountL = 0;
    const OVERMAX_NEED = 10;     // 10 muestras ~ 0.2s a 50Hz
    const OVERMAX_MARGIN = 1.05; // debe superar 5%

    function clamp(x, lo, hi) { return Math.max(lo, Math.min(hi, x)); }

    function normalize(env, base, max) {
      const denom = Math.max(1e-6, (max - base));
      const pct = 100 * (env - base) / denom;
      return clamp(pct, 0, 100);
    }

    function symmetryPct(rPct, lPct) {
      const s = rPct + lPct;
      if (s < 1e-6) return 100;
      const sym = 100 * (1 - Math.abs(rPct - lPct) / s);
      return clamp(sym, 0, 100);
    }

    // =========================
    // Calibration windows (robust)
    // =========================
    let calMode = "none"; // none | rest | max
    let calEndT = 0;
    let calBufR = [];
    let calBufL = [];

    function beginCal(mode, seconds) {
      calMode = mode;
      calEndT = performance.now() + seconds * 1000;
      calBufR = [];
      calBufL = [];
      if (mode === "rest") setStatus("Estado: Calibrando reposo...");
      if (mode === "max")  setStatus("Estado: Calibrando máximo...");
    }

    function handleCal(envR, envL) {
      const now = performance.now();
      if (now > calEndT) {
        if (calMode === "rest") {
          baseR = median(calBufR);
          baseL = median(calBufL);
          baseLocked = true;

          // asegurar distancia mínima base->max
          maxR = Math.max(maxR, baseR + 50);
          maxL = Math.max(maxL, baseL + 50);

          setStatus("Estado: Reposo calibrado ✅");
        }

        if (calMode === "max") {
          // percentil 95 para no dejar que un pico aislado arruine la escala
          maxR = Math.max(percentile(calBufR, 95), baseR + 50);
          maxL = Math.max(percentile(calBufL, 95), baseL + 50);
          maxLocked = true;

          setStatus("Estado: Máximo calibrado ✅");
        }

        calMode = "none";
        return;
      }

      calBufR.push(envR);
      calBufL.push(envL);
    }

    // =========================
    // Biofeedback timing
    // =========================
    let inRangeR = 0, inRangeL = 0, inRangeBoth = 0;

    // =========================
    // Reps
    // =========================
    function newRepState() {
      return { count: 0, inRep: false, startT: 0, peak: 0, sum: 0, auc: 0, n: 0, last: null };
    }
    let repR = newRepState();
    let repL = newRepState();

    function updateRep(rep, pct, t, dt) {
      const thrOff = thrOn * thrOffFactor;

      if (!rep.inRep) {
        if (pct >= thrOn) {
          rep.inRep = true;
          rep.startT = t;
          rep.peak = pct;
          rep.sum = pct;
          rep.auc = pct * dt;
          rep.n = 1;
        }
        return;
      }

      rep.peak = Math.max(rep.peak, pct);
      rep.sum += pct;
      rep.auc += pct * dt;
      rep.n += 1;

      if (pct < thrOff) {
        rep.inRep = false;
        rep.count += 1;
        const dur = Math.max(0, t - rep.startT);
        const mean = rep.sum / Math.max(1, rep.n);
        rep.last = { dur, peak: rep.peak, mean, auc: rep.auc };
        rep.sum = 0; rep.auc = 0; rep.n = 0; rep.peak = 0;
      }
    }

    function fmtRep(rep) {
      if (!rep) return "—";
      return `Dur: ${rep.dur.toFixed(2)}s · Pico: ${rep.peak.toFixed(1)}% · Prom: ${rep.mean.toFixed(1)}% · AUC: ${rep.auc.toFixed(1)} %·s`;
    }

    function refreshRepUI() {
      repCountText.textContent = `D: ${repR.count} · I: ${repL.count}`;
      repRightText.textContent = fmtRep(repR.last);
      repLeftText.textContent  = fmtRep(repL.last);
    }

    // =========================
    // Timer & rate
    // =========================
    function setStatus(text){ statusEl.textContent = text; }

    function formatTime(sec) {
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      const d = Math.floor((sec - Math.floor(sec)) * 10);
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}.${d}`;
    }

    function startTimer() {
      stopTimer();
      const tick = () => {
        if (!isMeasuring) return;
        const t = (performance.now() - t0) / 1000;
        timerText.textContent = formatTime(t);
        timerRAF = requestAnimationFrame(tick);
      };
      timerRAF = requestAnimationFrame(tick);
    }

    function stopTimer() {
      if (timerRAF) cancelAnimationFrame(timerRAF);
      timerRAF = null;
    }

    function resetRate() {
      lastRateT = performance.now();
      notifCount = 0;
      ratePill.textContent = "0.0 Hz";
    }

    function updateRate() {
      const now = performance.now();
      const elapsed = (now - lastRateT) / 1000;
      if (elapsed >= 1.0) {
        const hz = notifCount / elapsed;
        ratePill.textContent = `${hz.toFixed(1)} Hz`;
        notifCount = 0;
        lastRateT = now;
      }
    }

    // =========================
    // Charts
    // =========================
    function targetShapes() {
      return [{
        type: "rect",
        xref: "paper",
        yref: "y",
        x0: 0, x1: 1,
        y0: targetLow,
        y1: targetHigh,
        fillcolor: "rgba(0,0,0,0.06)",
        line: { width: 0 }
      }];
    }

    function initCharts() {
      const commonLayout = (title) => ({
        title,
        margin: { t: 45, l: 55, r: 20, b: 45 },
        xaxis: { title: "Tiempo (s)" },
        yaxis: { title: "Activación (%)", range: [0, 100] },
        shapes: targetShapes()
      });

      Plotly.newPlot("chartRight", [{ x: [], y: [], mode: "lines", name: "Envolvente (%)" }], commonLayout("Pierna derecha"), { responsive: true });
      Plotly.newPlot("chartLeft",  [{ x: [], y: [], mode: "lines", name: "Envolvente (%)" }], commonLayout("Pierna izquierda"), { responsive: true });

      chartsInited = true;
    }

    function resetCharts() {
      Plotly.react("chartRight", [{ x: [], y: [], mode: "lines", name: "Envolvente (%)" }], {
        title: "Pierna derecha",
        margin: { t: 45, l: 55, r: 20, b: 45 },
        xaxis: { title: "Tiempo (s)" },
        yaxis: { title: "Activación (%)", range: [0, 100] },
        shapes: targetShapes()
      }, { responsive: true });

      Plotly.react("chartLeft", [{ x: [], y: [], mode: "lines", name: "Envolvente (%)" }], {
        title: "Pierna izquierda",
        margin: { t: 45, l: 55, r: 20, b: 45 },
        xaxis: { title: "Tiempo (s)" },
        yaxis: { title: "Activación (%)", range: [0, 100] },
        shapes: targetShapes()
      }, { responsive: true });
    }

    function applyTarget() {
      const lo = clamp(Number(targetLowEl.value), 0, 100);
      const hi = clamp(Number(targetHighEl.value), 0, 100);
      targetLow = Math.min(lo, hi);
      targetHigh = Math.max(lo, hi);
      targetLowEl.value = targetLow;
      targetHighEl.value = targetHigh;

      if (chartsInited) {
        Plotly.relayout("chartRight", { shapes: targetShapes() });
        Plotly.relayout("chartLeft", { shapes: targetShapes() });
      }
    }

    // =========================
    // Reset session
    // =========================
    function resetMeasurementState() {
      lastSampleT = null;

      // anti-spike buffers
      medBufR = [];
      medBufL = [];

      // calibration lock
      baseLocked = false;
      maxLocked = false;

      // default refs (conservadores)
      baseR = 0; baseL = 0;
      maxR = 200; maxL = 200;

      overMaxCountR = 0;
      overMaxCountL = 0;

      inRangeR = 0; inRangeL = 0; inRangeBoth = 0;

      repR = newRepState();
      repL = newRepState();
      refreshRepUI();

      actText.textContent = "D: 0% · I: 0%";
      symText.textContent = "100%";
      inRangeText.textContent = "D: 0.0s · I: 0.0s · Ambas: 0.0s";
      timerText.textContent = "00:00.0";

      calMode = "none";
      calBufR = [];
      calBufL = [];
    }

    // =========================
    // BLE connect/disconnect
    // =========================
    async function connect() {
      try {
        setStatus("Estado: Buscando dispositivo...");
        connectBtn.disabled = true;

        deviceRef = await navigator.bluetooth.requestDevice({
          filters: [{ name: DEVICE_NAME }],
          optionalServices: [SERVICE_UUID]
        });

        deviceRef.addEventListener("gattserverdisconnected", onDisconnected);

        setStatus("Estado: Conectando...");
        const server  = await deviceRef.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        characteristic = await service.getCharacteristic(CHAR_UUID);

        await characteristic.startNotifications();
        characteristic.addEventListener("characteristicvaluechanged", handleData);

        setStatus("Estado: Conectado");
        disconnectBtn.disabled = false;
        startBtn.disabled = false;
        stopBtn.disabled = true;

        measWrap.classList.add("hidden");
        isMeasuring = false;
        stopTimer();
        resetRate();

      } catch (error) {
        console.log(error);
        alert("Error de conexión: " + error);
        setStatus("Estado: Desconectado");
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
        startBtn.disabled = true;
        stopBtn.disabled = true;
      }
    }

    function startMeasurement() {
      if (!characteristic) return;

      if (!chartsInited) initCharts();
      else resetCharts();

      applyTarget();
      resetMeasurementState();

      measWrap.classList.remove("hidden");

      t0 = performance.now();
      isMeasuring = true;
      startBtn.disabled = true;
      stopBtn.disabled = false;

      resetRate();
      setStatus("Estado: Midiendo...");
      startTimer();
    }

    function stopMeasurement() {
      isMeasuring = false;
      stopBtn.disabled = true;
      startBtn.disabled = false;
      stopTimer();
      setStatus("Estado: Conectado (medición detenida)");
    }

    async function disconnect() {
      try {
        if (characteristic) characteristic.removeEventListener("characteristicvaluechanged", handleData);
        if (deviceRef && deviceRef.gatt.connected) deviceRef.gatt.disconnect();
      } catch (e) {
        console.log(e);
      } finally {
        onDisconnected();
      }
    }

    function onDisconnected() {
      setStatus("Estado: Desconectado");
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
      startBtn.disabled = true;
      stopBtn.disabled = true;

      characteristic = null;
      isMeasuring = false;
      stopTimer();

      measWrap.classList.add("hidden");
      ratePill.textContent = "0.0 Hz";
    }

    // =========================
    // Data handler: env1,env2 (mV)
    // =========================
    function handleData(event) {
      notifCount++;
      updateRate();
      if (!isMeasuring) return;

      let value = new TextDecoder().decode(event.target.value);
      value = value.replace(/\0/g, "").trim();

      const parts = value.split(",");
      if (parts.length < 2) return;

      let envR = Number(parts[0]);
      let envL = Number(parts[1]);
      if (!Number.isFinite(envR) || !Number.isFinite(envL)) return;

      // Anti-spike median
      envR = pushMedian(medBufR, envR);
      envL = pushMedian(medBufL, envL);

      const t = (performance.now() - t0) / 1000;

      // dt
      let dt = 0;
      if (lastSampleT !== null) dt = Math.max(0.001, t - lastSampleT);
      lastSampleT = t;

      // Calibration in progress
      if (calMode !== "none") {
        handleCal(envR, envL);
      } else {
        // Auto-baseline inicial si no calibran reposo:
        // durante los primeros 2s, si estás en reposo, esto te deja base estable.
        if (!baseLocked && t < 2.0) {
          calBufR.push(envR);
          calBufL.push(envL);
        }
        if (!baseLocked && t >= 2.0 && calBufR.length > 10) {
          baseR = median(calBufR);
          baseL = median(calBufL);
          baseLocked = true;
          maxR = Math.max(maxR, baseR + 50);
          maxL = Math.max(maxL, baseL + 50);
          calBufR = [];
          calBufL = [];
        }
      }

      // Auto-max seguro (si NO hicieron calibración máxima):
      // Solo sube el max si se mantiene alto varias muestras consecutivas
      if (!maxLocked) {
        if (envR > maxR * OVERMAX_MARGIN) overMaxCountR++; else overMaxCountR = 0;
        if (envL > maxL * OVERMAX_MARGIN) overMaxCountL++; else overMaxCountL = 0;

        if (overMaxCountR >= OVERMAX_NEED) { maxR = envR; overMaxCountR = 0; }
        if (overMaxCountL >= OVERMAX_NEED) { maxL = envL; overMaxCountL = 0; }

        // Asegurar separación mínima
        if (maxR < baseR + 50) maxR = baseR + 50;
        if (maxL < baseL + 50) maxL = baseL + 50;
      }

      // Normalizar
      const rPct = normalize(envR, baseR, maxR);
      const lPct = normalize(envL, baseL, maxL);

      // KPI
      actText.textContent = `D: ${rPct.toFixed(0)}% · I: ${lPct.toFixed(0)}%`;
      symText.textContent = `${symmetryPct(rPct, lPct).toFixed(0)}%`;

      // Biofeedback time in range
      const inR = (rPct >= targetLow && rPct <= targetHigh);
      const inL = (lPct >= targetLow && lPct <= targetHigh);
      if (dt > 0) {
        if (inR) inRangeR += dt;
        if (inL) inRangeL += dt;
        if (inR && inL) inRangeBoth += dt;
      }
      inRangeText.textContent = `D: ${inRangeR.toFixed(1)}s · I: ${inRangeL.toFixed(1)}s · Ambas: ${inRangeBoth.toFixed(1)}s`;

      // Reps
      updateRep(repR, rPct, t, dt);
      updateRep(repL, lPct, t, dt);
      refreshRepUI();

      // Charts
      Plotly.extendTraces("chartRight", { x: [[t]], y: [[rPct]] }, [0], MAX_POINTS);
      Plotly.extendTraces("chartLeft",  { x: [[t]], y: [[lPct]] }, [0], MAX_POINTS);
    }

    // =========================
    // UI events
    // =========================
    connectBtn.addEventListener("click", connect);
    disconnectBtn.addEventListener("click", disconnect);
    startBtn.addEventListener("click", startMeasurement);
    stopBtn.addEventListener("click", stopMeasurement);

    applyTargetBtn.addEventListener("click", applyTarget);

    thrRange.addEventListener("input", () => {
      thrOn = Number(thrRange.value);
      thrLabel.textContent = `${thrOn}%`;
    });

    calRestBtn.addEventListener("click", () => beginCal("rest", 2.0));
    calMaxBtn.addEventListener("click", () => beginCal("max", 3.0));
  </script>
</body>
</html>
